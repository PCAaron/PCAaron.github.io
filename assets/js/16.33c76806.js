(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{216:function(a,n,t){"use strict";t.r(n);var e=t(0),c=Object(e.a)({},(function(){var a=this,n=a.$createElement,t=a._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"使用-mocha-web3-js-ganache-编写合约测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用-mocha-web3-js-ganache-编写合约测试"}},[a._v("#")]),a._v(" 使用 mocha + web3.js + ganache 编写合约测试")]),a._v(" "),t("h2",{attrs:{id:"ganache-cli"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ganache-cli"}},[a._v("#")]),a._v(" ganache-cli")]),a._v(" "),t("blockquote",[t("p",[a._v("ganache-cli是以太坊节点仿真器软件ganache的命令行版本，就像是 Remix 中运行在内存中的 Javascript VM 测试网络，其方法调用、交易确认速度非常快，可以方便开发者快速进行以太坊DApp的开发与测试。\n而 ganache-cli 为 web3.js 提供了兼容的 provider，这样就可以通过 web3.js 把合约部署到 ganache-cli 提供的本地测试网络上，并且跟合约实例交互。")])]),a._v(" "),t("h2",{attrs:{id:"跑测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跑测试"}},[a._v("#")]),a._v(" 跑测试")]),a._v(" "),t("blockquote",[t("p",[a._v("测试时我们通常会把每次测试运行的环境隔离开，对应到智能合约测试，每次测试需要部署新的合约实例，然后针对新的实例做功能测试。\n测试内容：1.合约部署时传入的 brand 属性被正确存储；2.调用 setBrand 之后合约的 brand 属性被正确更新")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\nconst path=require('path')\nconst assert=require('assert')\nconst ganache=require('ganache-cli')\nconst Web3=require('web3')\n\n//获取bytecode\nconst contractPath=path.resolve(__dirname,'../compiled/Car.json')\nconst {interface,bytecode}=require(contractPath)\n\n//配置provider\nconst web3=new Web3(ganache.provider());\n\nlet accounts;\nlet contract;\nlet initialBrand='AUDI';\n\ndescribe('contract',()=>{\n    //跑单例时需要部署全新的合约实例，起隔离作用\n    beforeEach(async()=>{\n        accounts= await web3.eth.getAccounts()\n        console.log('合约部署账户:'+accounts[0])\n\n        contract=await new web3.eth.Contract(JSON.parse(interface))\n            .deploy({data:bytecode,arguments:[initialBrand]})\n            .send({from:accounts[0],gas:'1000000'});\n        console.log('合约部署成功：',contract.options.address)\n    })\n    // 单元测试\n    it('deploy a contract',()=>{\n        assert.ok(contract.options.address)\n    })\n\n    //测试：合约部署时传入的 brand 属性被正确存储\n    it('has initial brand',async()=>{\n        //contract.methods.brand().call()，调用合约上的方法，通常是取数据，立即返回\n        const brand=await contract.methods.brand().call()\n        assert.equal(brand,initialBrand)\n    })\n\n    // 测试：调用 setBrand 之后合约的 brand 属性被正确更新\n    it('can change the brand',async()=>{\n        const newBrand='BWM'\n        //contract.methods.setBrand('xxx').send()，对合约发起交易，通常是修改数据，返回的是交易 Hash\n        await contract.methods.setBrand(newBrand).send({from:accounts[0]})\n        const brand=await contract.methods.brand().call()\n        assert.equal(brand,newBrand)\n    })\n\n})\n\n\n\n\n\n")])])]),t("h2",{attrs:{id:"测试截图："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#测试截图："}},[a._v("#")]),a._v(" 测试截图：")]),a._v(" "),t("p",[t("img",{attrs:{src:"/images/jinjie5_1.png",alt:"测试截图"}})]),a._v(" "),t("h2",{attrs:{id:"star-or-打赏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#star-or-打赏"}},[a._v("#")]),a._v(" star or 打赏")]),a._v(" "),t("blockquote",[t("p",[a._v("Imtoken地址: 0x4a6Ac825993737a4f7F1ed12fcAc1b27e247c55A")])]),a._v(" "),t("blockquote",[t("p",[a._v("打赏码\n"),t("img",{attrs:{src:"/wxzz.jpg",alt:"赞助支持"}})])])])}),[],!1,null,null,null);n.default=c.exports}}]);